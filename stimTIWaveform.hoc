python_on = nrnpython("print('Using python generated waveforms')") // check python connection
// python_on = 0
if (python_on) {
    USE_PYTHON = 1
} else {
    USE_PYTHON = 0
    printf("Python connection not set; cannot change duty cycle or pulse width\n")
}

objref tvec, stimvec

stimvec = new Vector()
tvec = new Vector()

objref veclist  // will hold all the stim Vectors

objref p, stim_all, stim_tmp, tvec_tmp // for creating stim arrays in python

double A_ratio[2] // current ratio

// DEFAULT GUI VALUES
waveform_mode = 1 // Sinusoidal TI
CF = 1000
PF = 5
AMP = 200
AMP_R1 = 1
AMP_R2 = 1
DC = 100
PW = 1000/PF*DC/100
STIM = 1000
RAMP_UP = 500
RAMP_DOWN = 500
PER = 10 //Percentage

proc importstim() {

    p = new PythonObject()
    nrnpython("from waveforms import createPulsedSignal")

    plot_on = 0
    stim_all =  p.createPulsedSignal(f0, df, stim_t, dc, dt, phi1, phi2, A1, A2, \
        pre_t, post_t, ramp_up_t, ramp_down_t, plot_on, waveform_mode)

    stim_tmp = stim_all._[0] // python object (numpy array)
    tvec_tmp = stim_all._[1]

    stimvec.resize(0) // to clear
    tvec.resize(0)

    stimvec = stimvec.from_python(stim_tmp)
    tvec = tvec.from_python(tvec_tmp)

}

proc createstim() {

    // *** DC CURRENT CONDITION ***
    if (f0 == 0 && df == 0) {
      //Carrier freq and df must be zero
      // this uses interpolated play
      // index    0  1    2    3        4        5
      // stim vec 0, 0,   1,   1,       0        0
      // time vec 0, DEL, DEL, DEL+DUR, DEL+DUR, DEL+DUR+1
      //  really  0, $1,  $1,  $1+$2,   $1+$2,   $1+$2+1
      // first the stim vector
      pre_t = 50

      stimvec.resize(6) //six elements, see above
      stimvec.fill(0)
      stimvec.x[2]=1
      stimvec.x[3]=1
      stimvec.mul(A)    //multiply the vector by the amplitude

      // now the time vector
      tvec.resize(6)
      tvec.x[1]=pre_t
      tvec.x[2]=pre_t
      tvec.x[3]=pre_t+stim_t
      tvec.x[4]=pre_t+stim_t
      tvec.x[5]=pre_t+stim_t+1

    // *** SINUSOIDAL CURRENT CONDITION ***
    } else {

        // dt = 0.01 // ms // use dt from GUI instead

        // add 1000 ms of zeros at the beginning and 100ms at the end of stim
        pre_t = 100
        post_t = 100

        // add ramping to the signal
        stim_t_tot = stim_t + ramp_up_t + ramp_down_t

        stim_pts = stim_t_tot/dt // stim time = stim_pts * dt

        pre_pts = pre_t/dt
        post_pts = post_t/dt
        tot_pts = pre_pts + stim_pts + post_pts


        A1 = A*A_ratio[0]/(A_ratio[0]+A_ratio[1])
        A2 = A*A_ratio[1]/(A_ratio[0]+A_ratio[1])


        if (df == 0 || f0 == 0) {
            phi1 = -PI/2
            phi2 = -PI/2

        } else {
            phi1 = 0
            phi2 = PI
        }


        if (USE_PYTHON){
            // *** CREATE WAVEFORM USING PYTHON SCRIPT ***
            importstim()

        } else {
            // *** SIMPLE TI ONLY ***

            tvec.resize(tot_pts)
            stimvec.resize(tot_pts)

            f1 = f0+df

            if (f0 == 0) {
                f0 = f1
            }

            f0_ms = f0/1000 // convert to ms
            f1_ms = f1/1000


            // pre time
            for i=0, pre_pts-1 {
                tvec.x[i] = i*dt
                stimvec.x[i] = 0
            }


            // TI signal
            for i=pre_pts, stim_pts+pre_pts-1 {
                cur_t = i*dt
                tvec.x[i] = cur_t
                offset_t = (i-pre_pts)*dt // start signal from time 0
                I1 = A1*cos(2*PI*f0_ms*offset_t+phi1)
                I2 = A2*cos(2*PI*f1_ms*offset_t+phi2)
                stimvec.x[i] = I1+I2
            }


            // ramp up
            if (ramp_up_t > 0) {
                ramp_pts = ramp_up_t/dt // timepoints
                dr = 1/ramp_pts

                for i=pre_pts, pre_pts+ramp_pts-1 {
                    ramp_scaling = (i-pre_pts)*dr
                    stimvec.x[i] = stimvec.x[i]*ramp_scaling
                }
            }

            // ramp down
            if (ramp_down_t > 0) {
                ramp_pts = ramp_down_t/dt // timepoints
                dr = 1/ramp_pts

                for i=pre_pts+stim_pts-ramp_pts, pre_pts+stim_pts-1 {
                    ramp_scaling = (pre_pts+stim_pts-i)*dr
                    stimvec.x[i] = stimvec.x[i]*ramp_scaling
                }
            }

            // post time
            for i=pre_pts+stim_pts, tot_pts-1 {
                tvec.x[i] = i*dt
                stimvec.x[i] = 0
            }
        }
    }
}

objref tmstimvec
proc setEstim() { //localobj tmstimvec //, tmstimvec2

    veclist = new List()

    // forall insert extracellular

    forall {
        if(ismembrane("xtra")){
            tmstimvec = stimvec.c //copy of stimvec
            tmstimvec.play(&stim_xtra, tvec,1) // "interpolated" play

            veclist.append(tmstimvec)
        }
    }
}

//Vectors to record soma responses
objref somt, somv, somina, sominats2, sominap, somik, somikim, somikps, somikts, somikE2, somikv3
objref somca, somcaCa, somcaHVA, somcaLVA, somih, somcap, sompas

somt = new Vector()
somv = new Vector()
somina = new Vector()
sominats2 = new Vector()
sominap = new Vector()
somik = new Vector()
somikim = new Vector()
somikps = new Vector()
somikts = new Vector()
somikE2 = new Vector()
somikv3 = new Vector()
somca = new Vector()
somcaCa = new Vector()
somcaHVA = new Vector()
somcaLVA = new Vector()
somih = new Vector()
somcap = new Vector()
sompas = new Vector()

//Vectors to record dendrite responses
objref dent, denv, denina, deninats2, deninap, denik, denikim, denikps, denikts, denikv3, denih, dencap, denpas

dent = new Vector()
denv = new Vector()
denina = new Vector()
deninats2 = new Vector()
deninap = new Vector()
denik = new Vector()
denikim = new Vector()
denikps = new Vector()
denikts = new Vector()
denikv3 = new Vector()
denih = new Vector()
dencap = new Vector()
denpas = new Vector()

//Vectors to record axon responses
objref axt, axv, axina, axinata, axinap, axik, axikps, axikts, axikv3, axicap, axipas

axt = new Vector()
axv = new Vector()
axina = new Vector()
axinata = new Vector()
axinap = new Vector()
axik = new Vector()
axikps = new Vector()
axikts = new Vector()
axikv3 = new Vector()
axicap = new Vector()
axipas = new Vector()

//Check which cell has been chosen to save its respective response or block its respective channels
if (cell_id == 6){
    load_file("PC6.hoc")
}else if (cell_id == 7){
    load_file("PC7.hoc")
}else if (cell_id == 8){
    load_file("PC8.hoc")
}else if (cell_id == 9){
    load_file("PC9.hoc")
}else if (cell_id == 10){
    load_file("PC10.hoc")
}else if (cell_id == 11){
    load_file("LBC11.hoc")
}else if (cell_id == 12){
    load_file("LBC12.hoc")
}else if (cell_id == 13){
    load_file("LBC13.hoc")
}else if (cell_id == 14){
    load_file("LBC14.hoc")
}else if (cell_id == 15){
    load_file("LBC15.hoc")
}else{
    printf("Create a file .hoc like PC6.hoc for that model and add it to this if-else block\n\n")
}

//To count the number of spikes
objref thre

proc runstim() {

    f0 = $1 // all variables are global unless specified as local
    df = $2
    dc = $3/100 // to fraction
    A = $4
    A_ratio[0] = $5
    A_ratio[1] = $6
    stim_t = $7
    ramp_up_t = $8
    ramp_down_t = $9
    change_dc = $10
    per = $11

    //Number of spikes measured in soma when the polarization amplitude is at least 0 mV
    cell.soma[0] thre = new APCount(0.5)
    thre.thresh = 0

    if (waveform_mode==1){
        if (change_dc) {
            setdutycycle()
        } else {
            setpulsewidth()
        }
    }

    createstim()
    setEstim()

    //Record responses in different compartments
    comparmentrec()

    plot_waveform(A)

    if (USE_PYTHON) {
        printf("Generated waveform with carrier f = %g Hz, pulse f = %g Hz, \
         duty cycle = %g, pulse width = %g ms, A = %g mV,\
         stim time = %g ms, ramp up time = %g ms, ramp down time = %g ms\n\n",f0,df,dc*100,pw,A,stim_t,ramp_up_t,ramp_down_t)
    } else {
        printf("Generated waveform with carrier f = %g Hz, pulse f = %g Hz, A = %g mV, \
        stim time = %g ms, ramp up time = %g ms, ramp down time = %g ms\n\n",f0,df,A,stim_t,ramp_up_t,ramp_down_t)
    }

    //Emax = stimvec.max

}

proc setpulsewidth() {
    DC_max = 100
    DC_min = 0.1
    if (DC > DC_max || USE_PYTHON == 0) {
        DC = DC_max
        dc = DC/100
    }
    if (DC < DC_min) {
        DC = DC_min
        dc = DC/100
    }

    if (PF > 0){
        PW = 1000/PF*DC/100
    } else{
        PW = 0
    }

    pw = PW
}

proc setdutycycle() {
    DC_max = 100

    if (PF > 0) {
        DC = PW/(1000/PF)*100
        pw = PW
        dc = DC/100 // input to createPulsedSignal
    } else {
        DC = 2 // go to next loop
    }

    if (DC > DC_max || USE_PYTHON == 0) {
        DC = DC_max
        dc = DC/100
        setpulsewidth()
    }
}


objref g1
proc plot_waveform() {
	g1 = new Graph(0)
	g1.size(0,stimvec.size(),-1, $1)
	stimvec.plot(g1,tvec)
  if ($1 > 0){ // anodic pulse
    if (f0 > 0 || df > 0) {
      g1.view(0,-$1*1.4,tvec.x[tvec.size()-1],$1*2.8, 1081, 547, 300.48, 200.32)
    } else {
      g1.view(0,-$1/2,tvec.x[tvec.size()-1],$1*2,1081, 547, 300.48, 200.32)
    }
  }	else { // cathodic pulse
    g1.view(0,$1*3/2,tvec.x[tvec.size()-1],-$1*2,1081, 547, 300.48, 200.32)
  }
}

// func totalcm() { local tmp
//   tmp = 0
//   forall for (x,0) tmp += area(x)*cm(x)
//   return tmp
// }


proc totalcm() {
    // area = um^2 = 1e-08 cm^2
    // cm = uF/cm^2
    // tot cm = pF

    tot_cm = 0
    forall {
        for (x,0) {
            tot_cm += area(x)*1e-8*1e6*cm(x) // 1e-8 (uF) -> 1e6 (pF)
        }
    }
    printf("Total cm for the selected cell = %g pF \n",tot_cm)
}


xpanel("Waveform parameters", 0)
xradiobutton("Sin TI","waveform_mode=1",1)
xradiobutton("PWM TI","waveform_mode=2")
xvalue("Carrier frequency (Hz) ", "CF", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Pulse frequency (Hz)", "PF", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Duty cycle (%)", "DC", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Pulse width (ms)", "PW", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,1)", 0, 1)
xvalue("Amplitude (uA or V/m)", "AMP", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Amp ratio 1", "AMP_R1", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Amp ratio 2", "AMP_R2", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Stimulation time (ms)", "STIM", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Ramp up time (ms) ", "RAMP_UP", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Ramp down time (ms) ", "RAMP_DOWN", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xvalue("Percentage (%) ", "PER", 1, "runstim(CF,PF,DC,AMP,AMP_R1,AMP_R2,STIM,RAMP_UP,RAMP_DOWN,PER,0)", 0, 1)
xpanel(300,350)
